import datetime
import os
import re

from agent.config import PROJECT_ROOT
from agent.event_logger import EventLogger
from agent.git_tools import changed_files, commit_all, create_branch, current_branch, diff_summary, is_git_repo
from agent.quality import run_quality_gate


def _slug(text: str) -> str:
    s = re.sub(r"[^a-zA-Z0-9]+", "-", text.strip().lower()).strip("-")
    return s[:40] or "agent-change"


def default_branch_name(goal: str) -> str:
    date = datetime.datetime.utcnow().strftime("%Y%m%d")
    return f"agent/{date}-{_slug(goal)}"


def default_commit_message(goal: str) -> str:
    return f"feat(agent): {goal.strip()[:72]}"


def _checklist(details: dict) -> tuple[str, bool]:
    fast = details.get("fast", [])
    full = details.get("full", [])

    def stage_ok(rows, stage):
        for r in rows:
            if r.get("stage") == stage:
                return r.get("exit_code") == 0
        return False

    format_ok = stage_ok(full or fast, "format")
    lint_ok = stage_ok(full or fast, "lint")
    tests_ok = stage_ok(full or fast, "tests")

    body = (
        f"- [{'x' if format_ok else ' '}] format\n"
        f"- [{'x' if lint_ok else ' '}] lint\n"
        f"- [{'x' if tests_ok else ' '}] tests\n"
    )
    return body, (format_ok and lint_ok and tests_ok)


def _build_pr_text(goal: str, branch: str, commit_message: str, diff_text: str, checklist_md: str) -> tuple[str, str]:
    title = f"{commit_message}"
    body = (
        "## Summary\n"
        f"- Goal: {goal}\n"
        f"- Branch: {branch}\n"
        f"- Commit: {commit_message}\n\n"
        "## Changes\n"
        "- Automated changes generated by Stella agent\n"
        "- Quality checks executed by agent pipeline\n\n"
        "## Diff Overview\n"
        f"```\n{diff_text[:1800]}\n```\n\n"
        "## Validation\n"
        f"{checklist_md}"
    )
    return title, body


def _write_pr_markdown(title: str, body: str) -> str:
    pr_dir = os.path.join(PROJECT_ROOT, ".stella")
    os.makedirs(pr_dir, exist_ok=True)
    out_path = os.path.join(pr_dir, "last_pr.md")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(f"# {title}\n\n{body}\n")
    return out_path


def prepare_pr(goal: str, branch: str | None = None, commit_message: str | None = None) -> dict:
    logger = EventLogger()

    if not is_git_repo():
        summary = (
            "PR Ready: no\n"
            "Reason: current folder is not a git repository\n"
            "Action: run `git init` (or clone repo), then retry `python main.py pr-ready ...`"
        )
        logger.log("pr_ready", {"ok": False, "reason": "not_git_repo"})
        return {"ok": False, "summary": summary}

    changed = changed_files()
    quality_ok, quality_details = run_quality_gate(changed_files=changed)
    checklist_md, checklist_ok = _checklist(quality_details)

    branch_name = branch or default_branch_name(goal)
    commit_msg = commit_message or default_commit_message(goal)

    b_code, b_out = create_branch(branch_name)
    d_out = diff_summary()
    c_code, c_out = commit_all(commit_msg)
    branch_after = current_branch() or "unknown"

    title, body = _build_pr_text(
        goal=goal,
        branch=branch_after,
        commit_message=commit_msg,
        diff_text=d_out,
        checklist_md=checklist_md,
    )
    pr_file = _write_pr_markdown(title, body)

    ok = b_code == 0 and c_code == 0 and quality_ok and checklist_ok
    pr_summary = (
        f"PR Ready: {'yes' if ok else 'no'}\n"
        f"branch: {branch_after}\n"
        f"commit_message: {commit_msg}\n"
        f"quality_gate: {'ok' if quality_ok else 'failed'}\n"
        f"branch_cmd_exit: {b_code}\n"
        f"commit_cmd_exit: {c_code}\n"
        f"pr_text_file: {pr_file}\n"
        f"branch_output:\n{b_out[:600]}\n\n"
        f"diff_summary:\n{d_out[:1500]}\n\n"
        f"commit_output:\n{c_out[:600]}"
    )

    result = {
        "ok": ok,
        "branch": branch_after,
        "commit_message": commit_msg,
        "pr_title": title,
        "pr_body": body,
        "pr_file": pr_file,
        "quality": quality_details,
        "summary": pr_summary,
    }
    logger.log("pr_ready", {"ok": ok, "branch": branch_after, "quality_ok": quality_ok})
    return result
